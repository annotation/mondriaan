
# Corpus annotation - mondriaan

## How a TF dataset represents a corpus

A TF dataset contains: 

*   textual objects as a set of nodes;
*   textual positions as a range of slots, which are also nodes;
*   nodes are represented as numbers;
*   nodes are divided in types, which have a name;
*   non-slot nodes are linked to slots;
*   all data about textual positions and objects are in features,
    which map nodes to values;
*   features have a name, and each feature is stored in a separate file with that name;
*   in particular, the text itself is stored in one or more features;
*   there are a few standard features that are present in every TF dataset;
*   See the
    [Text-Fabric datamodel](https://annotation.github.io/text-fabric/tf/about/datamodel.html).

In this dataset, **tokens** fullfill the role of slots.

## How TEI maps to TF

*   Text-Fabric *token nodes* correspond to **tokens** in TEI element content;
*   Text-Fabric *node types* correspond to TEI *element names (tags)*;
*   Text-Fabric *non-token nodes* correspond to TEI *elements in the source*;
*   Text-Fabric *features* correspond to TEI *attributes*;
*   Text-Fabric *edges* correspond to *relationships* between TEI elements;

    *   `parent` edges correspond to TEI elements and their parent elements 


    *   `sibling` edges correspond to TEI elements and their sibling elements 

*   Here are the [TEI elements and attributes](elements.md) used in this corpus.

*   Text-Fabric *node types* that start with a `?` correspond to TEI processing 
    instruction with that node type as target. The attributes of the processing
    instruction translate to TF features. As to the link to slots: it is
    treated as if it were an empty element.


*   Processing instructions in the TEI are ignored and do not leave any trace in the
    TF data.



The conversion may invoke custom code which may generate extra features.
For these features, metadata may have been declared, and it will show in the
generated documentation.


Tokens and sentence boundaries have been generated by a Natural Language
Pipeline, such as Spacy.


The TEI to TF conversion is an almost literal and very faithful transformation from
the TEI source files to a Text-Fabric data set.

## TF nodes and features overview

(only in as far they are not in 1-1 correspondence with TEI elements and attributes)



### node type `folder`

*The type of subfolders of TEI documents.*

**Section level 1**

**Features**

feature | description
--- | ---
`folder` | name of the subfolder

### node type `letter`

*The type of individual TEI documents.*

**Section level 2**

**Features**

feature | description
--- | ---
`letter` | name of the file, without the `.xml` extension. Other extensions are included.





### node type `chunk`


*Top-level division of material in a TEI document.*




**Section level 3**

**Features**



feature | description
--- | ---
`chunk` | sequence number of the chunk within the letter, starting with 1.






### node type `sentence`

*Sentences, i.e. material between full stops and several other punctuation marks*.

feature | description
--- | ---
`nsent` | the sequence number of the sentence within the corpus



### node type `token`

*Individual tokens, without space or punctuation.*



**Slot type.**


**Features**

feature | description
--- | ---
`str` | the characters of the token, without soft hyphens.
`after` | the space after the word, if present, otherwise the empty string.
`is_meta` | whether a token is in the teiHeader element
`is_note` | whether a token is in a note element
`rend_`*r* | whether a token is under the influence of a `rend="`*r*`"` attribute.



## Edge features

feature | description
--- | ---
`parent` | from a node to the node that corresponds to the parent element

`sibling` | from a node to all nodes that correspond to a preceding sibling element; the edges are labelled with the distance between the siblings; adjacent siblings have distance 1


Note that edges can be traversed in both directions, see the
[docs](https://annotation.github.io/text-fabric/tf/core/edgefeature.html).



* `E.parent.f(node)` finds the parent of a node
* `E.parent.t(node)` finds the children of a node





* `E.sibling.f(node)` finds the *preceding* siblings of a node
* `E.sibling.t(node)` finds the *succeeding* siblings of a node
* `E.sibling.b(node)` finds *all* siblings of a node



## Extra features


## msid


                    The values of this feature have type str.
                    * `meta`: {'description': 'The manuscript identifier of a letter; ', 'conversionMethod': 'derived', 'conversionCode': 'tt'}
* `path`: ['idno', 'msIdentifier', 'msDesc', 'sourceDesc']
* `nodeType`: letter



## letterid


                    The values of this feature have type str.
                    * `meta`: {'description': 'The identifier of a letter; ', 'conversionMethod': 'derived', 'conversionCode': 'tt'}
* `path`: [{'idno': {'type': 'letterId'}}, 'altIdentifier', 'msIdentifier', 'msDesc', 'sourceDesc']
* `nodeType`: letter



## country


                    The values of this feature have type str.
                    * `meta`: {'description': 'The country of preservation of a letter; ', 'conversionMethod': 'derived', 'conversionCode': 'tt'}
* `path`: ['country', 'msIdentifier', 'msDesc', 'sourceDesc']
* `nodeType`: letter



## institution


                    The values of this feature have type str.
                    * `meta`: {'description': 'The place where a letter is preserved; ', 'conversionMethod': 'derived', 'conversionCode': 'tt'}
* `path`: ['institution', 'msIdentifier', 'msDesc', 'sourceDesc']
* `nodeType`: letter



## correspondent


                    The values of this feature have type str.
                    * `meta`: {'description': 'The person that Mondriaan corresponded with; ', 'conversionMethod': 'derived', 'conversionCode': 'tt'}
* `path`: ['name', {'correspAction': {'type': 'received'}}, 'correspDesc', 'profileDesc']
* `nodeType`: letter



## sender


                    The values of this feature have type str.
                    * `meta`: {'description': 'The sender of the letter; ', 'conversionMethod': 'derived', 'conversionCode': 'tt'}
* `path`: ['name', {'correspAction': {'type': 'sent'}}, 'correspDesc', 'profileDesc']
* `nodeType`: letter



## period


                    The values of this feature have type str.
                    * `meta`: {'description': 'The date of the letter in YYYY-MM-DD; ', 'conversionMethod': 'derived', 'conversionCode': 'tt'}
* `path`: ['date@when', {'correspAction': {'type': 'sent'}}, 'correspDesc', 'profileDesc']
* `nodeType`: letter



## periodlong


                    The values of this feature have type str.
                    * `meta`: {'description': 'The date of the letter as description; ', 'conversionMethod': 'derived', 'conversionCode': 'tt'}
* `path`: ['date', {'correspAction': {'type': 'sent'}}, 'correspDesc', 'profileDesc']
* `nodeType`: letter



## location


                    The values of this feature have type str.
                    * `meta`: {'description': 'The place from where the letter is sent; ', 'conversionMethod': 'derived', 'conversionCode': 'tt'}
* `path`: ['placeName', {'correspAction': {'type': 'sent'}}, 'correspDesc', 'profileDesc']
* `nodeType`: letter



## personref


                    The values of this feature have type str.
                    * `meta`: {'description': 'Reference key to the details of a person; ', 'conversionMethod': 'derived', 'conversionCode': 'tt'}
* `path`: [{'rs@ref': {'type': 'person'}}]
* `nodeType`: rs



## artmondriaanref


                    The values of this feature have type str.
                    * `meta`: {'description': 'Reference key to the details of an artwork by Mondriaan; ', 'conversionMethod': 'derived', 'conversionCode': 'tt'}
* `path`: [{'rs@key': {'type': 'artwork-m'}}]
* `nodeType`: rs



## artref


                    The values of this feature have type str.
                    * `meta`: {'description': 'Reference key to the details of an artwork; ', 'conversionMethod': 'derived', 'conversionCode': 'tt'}
* `path`: [{'rs@key': {'type': 'artwork'}}]
* `nodeType`: rs



## exhibitionref


                    The values of this feature have type str.
                    * `meta`: {'description': 'Reference key to the details of an exhibition; ', 'conversionMethod': 'derived', 'conversionCode': 'tt'}
* `path`: [{'rs@key': {'type': 'exhibition'}}]
* `nodeType`: rs




The conversion has not generated extra features by means of custom code.


## Sectioning

The material is divided into 3 levels of sections, mainly for the purposes
of text display.

But how these levels relate to the source material is a different matter.

The conversion supports a few sectioning models that specify this.
This aspect is *work-in-progress*, because TEI sources differ wildly in how they
are sectioned.
The sectioning models that are currently supported correspond to cases we have
encountered, we have not done exhaustive research into TEI sectioning in practice.

This corpus is converted with section **Model I**.



### Model I: folders and files

This model assumes that the source is a directory consisting of folders
consisting of xml files, the TEI files.

There are three section levels:

*   *folder* Level 1 heading corresponding to folders with TEI files;
    heading: the name of the folder;
*   *letter* Level 2 heading corresponding to individual TEI files;
    heading: the name of the file;
*   *chunk* Level 3 heading corresponding to top-level divisions in a TEI file;
    heading: the sequence number of the chunk within the file.

All section headings are stored in a feature with the same name as the type of the section:
*folder*, *letter*, *chunk*.

#### Details

1.  *chunk* nodes have been made as follows:

    *   `<facsimile>`, `<fsdDecl>`, `<sourceDoc>`, and `<standOff>` are chunks;
    *   immediate children of `<teiHeader>` are chunks;
    *   immediate children of `<text>` are chunks,
        except the *text structure* elements
        `<front>`, `<body>`, `<back>` and `<group>`;
    *   immediate children of the text structure elements are chunks,
    *   but not necessarily empty elements such as `<lb/>` and `<pb/>`.

1.  letters and folder are sorted in the lexicographic ordering of their names;
1.  the folder `__ignore__` is ignored.
1.  the headings consist of the names of the letters and folders
1.  the slots generated for empty elements are linked to the current chunk if there is
    a current chunk; otherwise they will be linked to the upcoming chunk.

There are no additional switches for tweaking the model further, at the moment.








## Token detection

Tokens have been detected by an NLP pipeline.
The values of tokens are either words or non-word characters.
White space is not part of the token.
Whether a token is followed by a space or not is in the feature `after`.

## Sentence detection
Sentences have been detected by an NLP pipeline.
They form a new nodetype, `sentence`, with just a sequence number as feature (`nsent`).


## Tokens

Whether characters of words  or tokens are taken as the basic unit (*slot*) is decided
by the parameter `wordAsSlot`, passed to the conversion, and whether tokens have been
provided later on.
(for this corpus the slot type is **token**).

### Tokens and empty elements

When empty elements occur, something must be done to anchor them to the text stream.

To such elements we add an empty token with the ZERO-WIDTH-SPACE (Unicode 200B) as
character/string value.

Such slots get the feature `empty` assigned with value 1.

### Tokens in general

1.  Spaces are stripped when they are between elements whose parent does not allow
    mixed content; other whitespace is reduced to a single space.
1.  However, after direct child elements of pure elements we add a single space
    or newline: if there is an ancestor with mixed content, we add a space;
    if the whole ancestry consists of pure elements (typically in the TEI header),
    we add a newline.
    
    
1.  All tokens inside the teiHeader will get the feature `is_meta` set to 1;
    for tokens inside the body, `is_meta` has no value.






## Text kinds and styled formatting

We record in additional features whether text occurs in metadata elements and
in note elements and what formatting specifiers influence the text.
These features are provided for `token` nodes, and have only one value: 1.
The absence of values means that the corresponding property does not hold.

The following features are added:

*   `is_meta`: 1 if the token occurs in inside the `<teiHeader>`, no
    value otherwise.
*   `is_note`: 1 if the token occurs in inside the `<note>`, no value otherwise.
*   `rend_`*r*: for any *r* that is the value of a `rend` attribute.

All these features are defined for `token` nodes.
For token nodes, the value of these features is set equal to what these features
are for their first character.

Special formatting for the `rend_`*r* features is supported for some values of *r*.
The conversion supports these out-of-the-box:

value | description
--- | ---
`above` | above the line
`b` | bold font weight
`below` | below the line
`bold` | bold font weight
`center` | horizontally centered text
`h1` | heading of level 1
`h2` | heading of level 2
`h3` | heading of level 3
`h4` | heading of level 4
`h5` | heading of level 5
`h6` | heading of level 6
`i` | cursive font style
`italic` | cursive font style
`italics` | cursive font style
`large` | large font size
`margin` | in the margin
`sc` | small-caps font variation
`small_caps` | small-caps font variation
`smallcaps` | small-caps font variation
`spaced` | widely spaced between characters
`spat` | widely spaced between characters
`sub` | as subscript
`sup` | as superscript
`super` | as superscript
`ul` | underlined text
`underline` | underlined text

It is possible for the corpus designer to add more formatting on a per-corpus
basis by adding it to the `display.css` in the app directory of the corpus.
Unsupported values get a generic kind of special format: an orange-like color.

Special formatting becomes visible when material is rendered in a `layout` text
format.

## Text formats

Text-formats regulate how text is displayed, and they can also determine
what text is displayed.

There are two kind of text-formats: those that start with the word `layout` and
those that start with `text`.

The `text` formats do not apply any kind of special formating, the `layout` formats
do.

We have the following formats:

*   `text-orig-full`: all text
*   `layout-orig-full`: all text, formatted in HTML

## Boundary conditions

XML is complicated, the TEI guidelines use that complexity to the full.
In particular, it is difficult to determine what the set of TEI elements is
and what their properties are, just by looking at the schemas, because they are full
of macros, indirections, and abstractions, which can be overridden in any particular
TEI application.

On the other hand, the resulting TF should consist of clearly demarcated node types
and a simple list of features. In order to make that happen, we simplify matters
a bit.


1.  Processing instructions (`<?proc a="b">`) are treated as empty elements with as tag
    the *target* with preceding `?` and as attributes its pseudo attributes.


1.  Processing instructions (`<?proc a="b">`) are ignored.
1.  Comments (`<!-- this is a comment -->`) are ignored.
1.  Declarations (`<?xml ...>` `<?xml-model ...>` `<?xml-stylesheet ...>`) are
    read by the parser, but do not leave traces in the TF output.
1.  The atrributes of the root-element (`<TEI>`) are ignored.
1.  Namespaces (`xmlns="http://www.tei-c.org/ns/1.0"`) are read by the parser,
    but only the unqualified names are distinguishable in the output as feature names.
    So if the input has elements `tei:abb` and `ns:abb`, we'll see just the node
    type `abb` in the output.

### Validation

We have used [lxml](https://lxml.de) for XML parsing. During `convert` it is not used
in validating mode, but we can trigger a validation step during `check`.

However, some information about the elements, in particular whether they allow
mixed content or not, has been gleaned from the schemas, and has been used
during conversion.

Care has been taken that the names of these extra nodes and features do not collide
with element/attribute names of the TEI.

            # Additional features

            ## msid


                    The values of this feature have type str.
                    * `meta`: {'description': 'The manuscript identifier of a letter; «base»', 'conversionMethod': 'derived', 'conversionCode': 'tt'}
* `path`: ['idno', 'msIdentifier', 'msDesc', 'sourceDesc']
* `nodeType`: letter



## letterid


                    The values of this feature have type str.
                    * `meta`: {'description': 'The identifier of a letter; «base»', 'conversionMethod': 'derived', 'conversionCode': 'tt'}
* `path`: [{'idno': {'type': 'letterId'}}, 'altIdentifier', 'msIdentifier', 'msDesc', 'sourceDesc']
* `nodeType`: letter



## country


                    The values of this feature have type str.
                    * `meta`: {'description': 'The country of preservation of a letter; «base»', 'conversionMethod': 'derived', 'conversionCode': 'tt'}
* `path`: ['country', 'msIdentifier', 'msDesc', 'sourceDesc']
* `nodeType`: letter



## institution


                    The values of this feature have type str.
                    * `meta`: {'description': 'The place where a letter is preserved; «base»', 'conversionMethod': 'derived', 'conversionCode': 'tt'}
* `path`: ['institution', 'msIdentifier', 'msDesc', 'sourceDesc']
* `nodeType`: letter



## correspondent


                    The values of this feature have type str.
                    * `meta`: {'description': 'The person that Mondriaan corresponded with; «base»', 'conversionMethod': 'derived', 'conversionCode': 'tt'}
* `path`: ['name', {'correspAction': {'type': 'received'}}, 'correspDesc', 'profileDesc']
* `nodeType`: letter



## sender


                    The values of this feature have type str.
                    * `meta`: {'description': 'The sender of the letter; «base»', 'conversionMethod': 'derived', 'conversionCode': 'tt'}
* `path`: ['name', {'correspAction': {'type': 'sent'}}, 'correspDesc', 'profileDesc']
* `nodeType`: letter



## period


                    The values of this feature have type str.
                    * `meta`: {'description': 'The date of the letter in YYYY-MM-DD; «base»', 'conversionMethod': 'derived', 'conversionCode': 'tt'}
* `path`: ['date@when', {'correspAction': {'type': 'sent'}}, 'correspDesc', 'profileDesc']
* `nodeType`: letter



## periodlong


                    The values of this feature have type str.
                    * `meta`: {'description': 'The date of the letter as description; «base»', 'conversionMethod': 'derived', 'conversionCode': 'tt'}
* `path`: ['date', {'correspAction': {'type': 'sent'}}, 'correspDesc', 'profileDesc']
* `nodeType`: letter



## location


                    The values of this feature have type str.
                    * `meta`: {'description': 'The place from where the letter is sent; «base»', 'conversionMethod': 'derived', 'conversionCode': 'tt'}
* `path`: ['placeName', {'correspAction': {'type': 'sent'}}, 'correspDesc', 'profileDesc']
* `nodeType`: letter



## personref


                    The values of this feature have type str.
                    * `meta`: {'description': 'Reference key to the details of a person; «base»', 'conversionMethod': 'derived', 'conversionCode': 'tt'}
* `path`: [{'rs@ref': {'type': 'person'}}]
* `nodeType`: rs



## artmondriaanref


                    The values of this feature have type str.
                    * `meta`: {'description': 'Reference key to the details of an artwork by Mondriaan; «base»', 'conversionMethod': 'derived', 'conversionCode': 'tt'}
* `path`: [{'rs@key': {'type': 'artwork-m'}}]
* `nodeType`: rs



## artref


                    The values of this feature have type str.
                    * `meta`: {'description': 'Reference key to the details of an artwork; «base»', 'conversionMethod': 'derived', 'conversionCode': 'tt'}
* `path`: [{'rs@key': {'type': 'artwork'}}]
* `nodeType`: rs



## exhibitionref


                    The values of this feature have type str.
                    * `meta`: {'description': 'Reference key to the details of an exhibition; «base»', 'conversionMethod': 'derived', 'conversionCode': 'tt'}
* `path`: [{'rs@key': {'type': 'exhibition'}}]
* `nodeType`: rs




## See also

*   [about](about.md)



